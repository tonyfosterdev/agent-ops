/**
 * useHitlState - Custom hook for tracking HITL (Human-in-the-Loop) state from events.
 *
 * ## Why This Hook Exists
 *
 * The @inngest/use-agent streaming reducer does not handle `hitl.requested` events.
 * The reducer's `applyEvent` function only handles specific events (run.started,
 * part.created, text.delta, etc.) and the default case simply returns the thread
 * unchanged. This means hitl.requested events are ignored.
 *
 * Additionally, `part.completed` hardcodes state transitions (tool.state = "input-available"),
 * so we cannot set `awaiting-approval` via part.completed events.
 *
 * ## Solution
 *
 * This hook intercepts events via the `onEvent` callback that useAgents provides.
 * We maintain separate HITL state in React and merge it with messages when rendering.
 *
 * ## Important: ID Mismatch and Tool Name Matching
 *
 * The `partId` field in hitl.requested events is a UUID generated by our tool handlers
 * (via step.run). This is DIFFERENT from the `toolCallId` in ToolCallUIPart, which is
 * generated independently by AgentKit's streaming context.
 *
 * Because these IDs don't match, we match HITL requests to tool-call parts by TOOL NAME
 * instead of by ID. The merge logic in Chat.tsx:
 * 1. Builds a map of pending HITL requests by tool name
 * 2. For each tool-call part in 'input-available' state, checks if there's a pending
 *    HITL request for that tool name
 * 3. If so, sets state to 'awaiting-approval' and attaches the HITL requestId
 *
 * The HITL requestId is then used for approval/denial API calls.
 *
 * ## Flow
 *
 * ```
 * Tool publishes hitl.requested (with our generated requestId/partId)
 *        |
 *        v
 * @inngest/use-agent receives event
 *        |
 *        +---> streaming-reducer ignores (default case)
 *        |
 *        +---> onEvent callback receives it (this hook)
 *                   |
 *                   v
 *             hitlRequests Map updated (keyed by our generated ID)
 *                   |
 *                   v
 *             Chat.tsx merges by TOOL NAME (not ID)
 *                   |
 *                   v
 *             tool-call part gets state='awaiting-approval' + hitlRequestId
 *                   |
 *                   v
 *             ToolCallPartRenderer shows approval buttons
 *                   |
 *                   v
 *             User approves -> uses hitlRequestId for API call
 *                   |
 *                   v
 *             Server sends agentops/tool.approval event with our requestId
 *                   |
 *                   v
 *             Tool's step.waitForEvent receives it and resumes
 * ```
 */

import { useState, useCallback } from 'react';
import type { AgentKitEvent, OnEventMeta } from '@inngest/use-agent';

/**
 * Represents a pending or resolved HITL approval request.
 */
export interface HitlRequest {
  /** Unique ID for this HITL request (generated by tool handler, used for approval API) */
  requestId: string;
  /**
   * Tool call ID from the event's partId field.
   * Note: This is the ID generated by our tool handlers, NOT the AgentKit toolCallId.
   * We match HITL requests to UI parts by tool name, not by this ID.
   */
  toolCallId: string;
  /** Name of the tool requiring approval */
  toolName: string;
  /** Input arguments to the tool */
  toolInput: unknown;
  /** Current approval status */
  status: 'pending' | 'approved' | 'denied';
  /** Reason for the approval request (from tool) */
  reason?: string;
  /** Risk level indicator */
  riskLevel?: string;
  /** When the approval request expires */
  expiresAt?: string;
}

/**
 * Expected shape of hitl.requested event data.
 * Used for runtime validation.
 */
interface HitlRequestedEventData {
  requestId: string;
  toolCalls: Array<{
    partId: string;
    toolName: string;
    toolInput: unknown;
  }>;
  metadata?: {
    reason?: string;
    riskLevel?: string;
  };
  expiresAt?: string;
}

/**
 * Expected shape of hitl.resolved event data.
 * Used for runtime validation.
 */
interface HitlResolvedEventData {
  requestId: string;
  toolCallId?: string;
  resolution: 'approved' | 'denied';
}

/**
 * Validates hitl.requested event data shape.
 * Provides defensive checks to prevent crashes from malformed events.
 */
function isValidHitlRequestedData(data: unknown): data is HitlRequestedEventData {
  if (!data || typeof data !== 'object') return false;

  const d = data as Record<string, unknown>;

  // requestId is required and must be a string
  if (typeof d.requestId !== 'string' || !d.requestId) return false;

  // toolCalls must be an array
  if (!Array.isArray(d.toolCalls)) return false;

  // Each toolCall must have partId and toolName
  for (const tc of d.toolCalls) {
    if (!tc || typeof tc !== 'object') return false;
    const toolCall = tc as Record<string, unknown>;
    if (typeof toolCall.partId !== 'string' || !toolCall.partId) return false;
    if (typeof toolCall.toolName !== 'string' || !toolCall.toolName) return false;
  }

  return true;
}

/**
 * Validates hitl.resolved event data shape.
 * Provides defensive checks to prevent crashes from malformed events.
 */
function isValidHitlResolvedData(data: unknown): data is HitlResolvedEventData {
  if (!data || typeof data !== 'object') return false;

  const d = data as Record<string, unknown>;

  // requestId is required and must be a string
  if (typeof d.requestId !== 'string' || !d.requestId) return false;

  // resolution must be 'approved' or 'denied'
  if (d.resolution !== 'approved' && d.resolution !== 'denied') return false;

  // toolCallId is optional but must be string if present
  if (d.toolCallId !== undefined && typeof d.toolCallId !== 'string') return false;

  return true;
}

/**
 * Custom hook for tracking HITL (Human-in-the-Loop) state from streaming events.
 *
 * @returns Object containing:
 * - hitlRequests: Map of toolCallId -> HitlRequest
 * - handleEvent: Callback to pass to useAgents onEvent
 * - clearResolved: Function to remove resolved requests from state
 */
export function useHitlState() {
  const [hitlRequests, setHitlRequests] = useState<Map<string, HitlRequest>>(
    new Map()
  );

  /**
   * Event handler callback for useAgents onEvent.
   * Intercepts hitl.requested and hitl.resolved events to maintain HITL state.
   */
  const handleEvent = useCallback((evt: AgentKitEvent, _meta: OnEventMeta) => {
    // Handle hitl.requested events
    if (evt.event === 'hitl.requested') {
      // Runtime validation - defensive check for event data shape
      if (!isValidHitlRequestedData(evt.data)) {
        console.warn('useHitlState: Received malformed hitl.requested event, ignoring:', evt.data);
        return;
      }

      const data = evt.data;

      // Create HITL request for each tool call in the event.
      // The partId in the event maps to toolCallId in ToolCallUIPart.
      data.toolCalls.forEach((tc) => {
        setHitlRequests((prev) => {
          const next = new Map(prev);
          next.set(tc.partId, {
            requestId: data.requestId,
            toolCallId: tc.partId,
            toolName: tc.toolName,
            toolInput: tc.toolInput,
            status: 'pending',
            reason: data.metadata?.reason,
            riskLevel: data.metadata?.riskLevel,
            expiresAt: data.expiresAt,
          });
          return next;
        });
      });
    }

    // Handle hitl.resolved events
    if (evt.event === 'hitl.resolved') {
      // Runtime validation - defensive check for event data shape
      if (!isValidHitlResolvedData(evt.data)) {
        console.warn('useHitlState: Received malformed hitl.resolved event, ignoring:', evt.data);
        return;
      }

      const data = evt.data;

      // Try to match by toolCallId first, fall back to requestId
      const id = data.toolCallId || data.requestId;

      setHitlRequests((prev) => {
        const next = new Map(prev);
        const existing = next.get(id);
        if (existing) {
          next.set(id, {
            ...existing,
            status: data.resolution === 'approved' ? 'approved' : 'denied',
          });
        }
        return next;
      });
    }

    // Handle stream.ended - clean up resolved requests
    // This prevents stale data from accumulating across multiple agent runs
    if (evt.event === 'stream.ended') {
      setHitlRequests((prev) => {
        const next = new Map(prev);
        for (const [id, req] of next) {
          if (req.status !== 'pending') {
            next.delete(id);
          }
        }
        return next;
      });
    }
  }, []);

  /**
   * Manually clear resolved (approved/denied) requests from state.
   * Useful for cleanup after a conversation ends or when starting a new thread.
   */
  const clearResolved = useCallback(() => {
    setHitlRequests((prev) => {
      const next = new Map(prev);
      for (const [id, req] of next) {
        if (req.status !== 'pending') {
          next.delete(id);
        }
      }
      return next;
    });
  }, []);

  /**
   * Clear all HITL requests (both pending and resolved).
   * Useful when starting a completely new conversation.
   */
  const clearAll = useCallback(() => {
    setHitlRequests(new Map());
  }, []);

  return { hitlRequests, handleEvent, clearResolved, clearAll };
}
