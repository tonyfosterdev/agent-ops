# Fix HITL Approval Button Not Appearing

## Problem

HITL events are being published correctly (confirmed in run `01KEDWRGHAY86P321WB3BSYWK4`), but the dashboard shows "input-available" badge instead of approval buttons.

## Root Cause (Corrected after Architecture Review)

The `@inngest/use-agent` streaming reducer **does not handle `hitl.requested` events**. Looking at `streaming-reducer.ts:480-541`, the `applyEvent` function only handles:
- `run.started`, `part.created`, `text.delta`, `tool_call.arguments.delta`
- `tool_call.output.delta`, `part.completed`, `run.completed`, `stream.ended`

The `default:` case (line 539) simply returns the thread unchanged, so `hitl.requested` events are ignored.

Additionally, `part.completed` hardcodes the state transitions (line 747: `tool.state = "input-available"`), so we cannot set `awaiting-approval` via `part.completed` events either.

## Solution: Use `onEvent` Callback + Custom HITL State + Tool Name Matching

The `useAgents` hook provides an `onEvent` callback that receives every raw event. We can:

1. Intercept `hitl.requested` events via `onEvent`
2. Maintain separate HITL state in React that tracks pending approvals
3. **Match by TOOL NAME** (not toolCallId) since AgentKit generates its own IDs
4. Merge HITL state with messages when rendering (set tool-call part state to `awaiting-approval`)
5. Attach the HITL requestId to the merged part for use in approval API calls

### Critical Discovery: ID Mismatch

The `toolCallId` in HITL events (generated by our tool handlers via `step.run()`) is DIFFERENT from
the `toolCallId` in `ToolCallUIPart` (generated by AgentKit's streaming context). These are
independent UUIDs that don't match.

**Solution**: Match HITL requests to tool-call parts by **tool name** instead of by ID. Then attach
the HITL `requestId` to the merged part so the approval API uses the correct ID.

```
Tool publishes hitl.requested
       │
       ▼
@inngest/use-agent receives event
       │
       ├──▶ streaming-reducer ignores (default case)
       │
       └──▶ onEvent callback receives it
                  │
                  ▼
            Custom HITL state updated
                  │
                  ▼
            Component re-renders with merged state
                  │
                  ▼
            ToolCallPartRenderer sees state='awaiting-approval'
                  │
                  ▼
            Approval buttons rendered
```

## Files to Modify

### 1. CREATE: `ops/dashboard/src/hooks/useHitlState.ts`

Custom hook to track HITL state from events:

```typescript
import { useState, useCallback } from 'react';
import type { AgentKitEvent, OnEventMeta } from '@inngest/use-agent';

export interface HitlRequest {
  requestId: string;
  toolCallId: string;
  toolName: string;
  toolInput: unknown;
  status: 'pending' | 'approved' | 'denied';
  reason?: string;
  riskLevel?: string;
  expiresAt?: string;
}

export function useHitlState() {
  const [hitlRequests, setHitlRequests] = useState<Map<string, HitlRequest>>(new Map());

  const handleEvent = useCallback((evt: AgentKitEvent, meta: OnEventMeta) => {
    if (evt.event === 'hitl.requested') {
      const data = evt.data as {
        requestId: string;
        toolCalls: Array<{ partId: string; toolName: string; toolInput: unknown }>;
        metadata?: { reason?: string; riskLevel?: string };
        expiresAt?: string;
      };

      // Create HITL request for each tool call
      data.toolCalls.forEach((tc) => {
        setHitlRequests((prev) => {
          const next = new Map(prev);
          next.set(tc.partId, {
            requestId: data.requestId,
            toolCallId: tc.partId,
            toolName: tc.toolName,
            toolInput: tc.toolInput,
            status: 'pending',
            reason: data.metadata?.reason,
            riskLevel: data.metadata?.riskLevel,
            expiresAt: data.expiresAt,
          });
          return next;
        });
      });
    }

    if (evt.event === 'hitl.resolved') {
      const data = evt.data as {
        requestId: string;
        toolCallId?: string;
        resolution: 'approved' | 'denied';
      };

      const id = data.toolCallId || data.requestId;
      setHitlRequests((prev) => {
        const next = new Map(prev);
        const existing = next.get(id);
        if (existing) {
          next.set(id, { ...existing, status: data.resolution === 'approved' ? 'approved' : 'denied' });
        }
        return next;
      });
    }
  }, []);

  const clearResolved = useCallback(() => {
    setHitlRequests((prev) => {
      const next = new Map(prev);
      for (const [id, req] of next) {
        if (req.status !== 'pending') {
          next.delete(id);
        }
      }
      return next;
    });
  }, []);

  return { hitlRequests, handleEvent, clearResolved };
}
```

### 2. MODIFY: `ops/dashboard/src/components/Chat.tsx`

Integrate HITL state with useAgents:

```typescript
import { useHitlState } from '../hooks/useHitlState';

export function Chat() {
  const { hitlRequests, handleEvent } = useHitlState();

  const {
    messages,
    status,
    sendMessage,
    approveToolCall,
    denyToolCall,
    error,
    clearError,
  } = useAgents({
    debug: true,
    onEvent: handleEvent,  // Pass the HITL event handler
  });

  // Merge HITL state into messages for rendering
  const messagesWithHitl = useMemo(() => {
    return messages.map((msg) => ({
      ...msg,
      parts: msg.parts?.map((part) => {
        if (part.type === 'tool-call') {
          const hitlReq = hitlRequests.get(part.toolCallId);
          if (hitlReq?.status === 'pending') {
            return { ...part, state: 'awaiting-approval' as const };
          }
        }
        return part;
      }),
    }));
  }, [messages, hitlRequests]);

  // Check for pending approvals
  const hasPendingApproval = Array.from(hitlRequests.values()).some(
    (req) => req.status === 'pending'
  );

  // ... rest of component uses messagesWithHitl instead of messages
}
```

### 3. KEEP: `ops/src/tools/types.ts`

Keep `createHitlRequestedEvent` as-is - it correctly creates `hitl.requested` events.

### 4. KEEP: `ops/src/server.ts`

Keep the approval endpoint. Verify it sends the correct Inngest event that tools are waiting for (`agentops/tool.approval`).

### 5. VERIFY: Tool `waitForEvent` event name alignment

Ensure tools wait for the same event that the approval endpoint sends:

```typescript
// In tools (shell-tools.ts, write-tools.ts, docker-tools.ts):
const approval = await step.waitForEvent(`wait-for-approval-${toolCallId}`, {
  event: 'agentops/tool.approval',  // Must match what server.ts sends
  if: `async.data.toolCallId == "${toolCallId}"`,
  timeout: '4h',
});
```

## Implementation Order (Updated per Architecture Review)

1. **Verify event names match** between server and tools (prerequisite check)
2. Create `useHitlState.ts` hook with:
   - Runtime validation for event data
   - Documentation of partId/toolCallId coupling
   - Cleanup on `stream.ended` event
3. Update `Chat.tsx` to use the hook and merge HITL state
4. Handle race condition (HITL event before tool-call part created)
5. Test end-to-end

## Architecture Review Conditions (Approved)

The following conditions must be addressed during implementation:

1. **Runtime validation** - Add defensive checks for event data shape
2. **Document coupling** - Comment explaining partId maps to toolCallId
3. **Cleanup integration** - Clear resolved requests on stream.ended
4. **Race condition handling** - Fallback UI when tool-call part not yet created

## Why This Works

1. **No changes to @inngest/use-agent needed** - We work with the hook as-is
2. **Uses official `onEvent` callback** - This is the intended extension point
3. **Minimal code changes** - Just a new hook and minor Chat.tsx updates
4. **Backward compatible** - Doesn't change event format or server API

## Backward Compatibility

- Tool implementations continue publishing `hitl.requested` events (unchanged)
- Server continues sending `agentops/tool.approval` events (unchanged)
- Only the dashboard interpretation changes

## Testing

```bash
docker compose up --build
# Open http://localhost:3001
# Send: "Write a file called test.txt with hello world"
# Verify: Tool shows with Approve/Deny buttons (state='awaiting-approval')
# Click Approve, verify file written
# Test deny flow with reason
```

## Alternative Approaches Considered

### A. Patch streaming reducer in @inngest/use-agent
- Requires maintaining a fork
- Changes would need to track upstream updates
- More invasive

### B. Emit `part.completed` with custom state
- Doesn't work - reducer hardcodes state transitions
- `part.completed` for tool-call always sets `input-available`

### C. Use HitlUIPart message parts
- Reducer doesn't handle `part.created` with `type: 'hitl'`
- Would require reducer changes anyway

## Key Learnings from Architecture Review

1. The streaming reducer ignores unknown events (no error, just `return thread`)
2. State transitions in `part.completed` are hardcoded, not read from event data
3. `onEvent` callback is the official extension point for custom event handling
4. The `HitlUIPart` type exists but isn't populated by the reducer
